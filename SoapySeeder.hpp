#include <string>
#include <memory> // unique_ptr, shared_ptr

#include <boost/thread.hpp> // thread, mutex

#include <SoapySDR/Device.hpp>
#ifdef SUPPORT_SOAPY_CONVERTERS
#include <SoapySDR/ConverterRegistry.hpp>
#endif


#include "SharedRingBuffer.hpp"
#include "SimpleSharedRingBuffer.hpp"
#include "TimestampedSharedRingBuffer.hpp"


class TransmitThreadDescription;

/***********************************************************************
 * Device interface
 **********************************************************************/
class SoapySeeder: public SoapySDR::Device
{
public:

	SoapySeeder(const SoapySDR::Kwargs &args);
	~SoapySeeder();

	std::string getDriverKey(void) const;

	size_t getNumChannels(const int dir) const;

	bool getFullDuplex(const int direction, const size_t channel) const;

	std::vector<std::string> getStreamFormats(const int direction, const size_t channel) const;

	SoapySDR::Stream* setupStream (const int direction, const std::string &format,
		const std::vector<size_t> &channels = std::vector<size_t>(),
		const SoapySDR::Kwargs &args = SoapySDR::Kwargs());

	void closeStream(SoapySDR::Stream *stream);

	int activateStream(SoapySDR::Stream *stream, const int flags=0, const long long timeNs=0, const size_t numElems=0);

	int deactivateStream(SoapySDR::Stream *stream, const int flags=0, const long long timeNs=0);

	int readStream(SoapySDR::Stream *stream, void *const *buffs, const size_t numElems, int &flags, long long &timeNs, const long timeoutUs=100000);

	int writeStream(SoapySDR::Stream *stream, const void *const *buffs, const size_t numElems, int &flags, const long long timeNs=0, const long timeoutUs=100000);

	int readStreamStatus(SoapySDR::Stream *stream, size_t &chanMask, int &flags, long long &timeNs, const long timeoutUs=100000);


	size_t getNumDirectAccessBuffers(SoapySDR::Stream *stream);

	int acquireReadBuffer(SoapySDR::Stream *stream, size_t &handle, const void **buffs, int &flags, long long &timeNs, const long timeoutUs=100000);
	void releaseReadBuffer(SoapySDR::Stream *stream, const size_t handle);

	int acquireWriteBuffer(SoapySDR::Stream *stream, size_t &handle, void **buffs, const long timeoutUs=100000);
	void releaseWriteBuffer(SoapySDR::Stream *stream, const size_t handle, const size_t numElems, int &flags, const long long timeNs=0);

	void setFrequency(const int direction, const size_t channel, const double frequency, const SoapySDR::Kwargs &args=SoapySDR::Kwargs());
	void setSampleRate(const int direction, const size_t channel, const double rate);


	/**********************************************
	 *
	 * Below are wrappers for the rest of methods.
	 * These are generated by generate_wrappers.py
	 *
	 **********************************************/

	std::string getHardwareKey(void) const {
		return slave->getHardwareKey();
	}

	SoapySDR::Kwargs getHardwareInfo(void) const {
		return slave->getHardwareInfo();
	}

	void setFrontendMapping(const int direction, const std::string & mapping) {
		return slave->setFrontendMapping(direction, mapping);
	}

	std::string getFrontendMapping(const int direction) const {
		return slave->getFrontendMapping(direction);
	}

	SoapySDR::Kwargs getChannelInfo(const int direction, const size_t channel) const {
		return slave->getChannelInfo(direction, channel);
	}

	std::string getNativeStreamFormat(const int direction, const size_t channel, double & fullScale) const {
		return slave->getNativeStreamFormat(direction, channel, fullScale);
	}

	SoapySDR::ArgInfoList getStreamArgsInfo(const int direction, const size_t channel) const {
		return slave->getStreamArgsInfo(direction, channel);
	}

	size_t getStreamMTU(SoapySDR::Stream * stream) const {
		return slave->getStreamMTU(stream);
	}

	int getDirectAccessBufferAddrs(SoapySDR::Stream * stream, const size_t handle, void * * buffs) {
		return slave->getDirectAccessBufferAddrs(stream, handle, buffs);
	}

	std::vector<std::string> listAntennas(const int direction, const size_t channel) const {
		assert(slave.get() != nullptr);
		return slave->listAntennas(direction, channel);
	}

	void setAntenna(const int direction, const size_t channel, const std::string & name) {
		return slave->setAntenna(direction, channel, name);
	}

	std::string getAntenna(const int direction, const size_t channel) const {
		return slave->getAntenna(direction, channel);
	}

	bool hasDCOffsetMode(const int direction, const size_t channel) const {
		return slave->hasDCOffsetMode(direction, channel);
	}

	void setDCOffsetMode(const int direction, const size_t channel, const bool automatic) {
		return slave->setDCOffsetMode(direction, channel, automatic);
	}

	bool getDCOffsetMode(const int direction, const size_t channel) const {
		return slave->getDCOffsetMode(direction, channel);
	}

	bool hasDCOffset(const int direction, const size_t channel) const {
		return slave->hasDCOffset(direction, channel);
	}

	void setDCOffset(const int direction, const size_t channel, const std::complex<double> & offset) {
		return slave->setDCOffset(direction, channel, offset);
	}

	std::complex<double> getDCOffset(const int direction, const size_t channel) const {
		return slave->getDCOffset(direction, channel);
	}

	bool hasIQBalance(const int direction, const size_t channel) const {
		return slave->hasIQBalance(direction, channel);
	}

	void setIQBalance(const int direction, const size_t channel, const std::complex<double> & balance) {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->setIQBalance(direction, channel, balance);
	}

	std::complex<double> getIQBalance(const int direction, const size_t channel) const {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->getIQBalance(direction, channel);
	}

	bool hasFrequencyCorrection(const int direction, const size_t channel) const {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->hasFrequencyCorrection(direction, channel);
	}

	void setFrequencyCorrection(const int direction, const size_t channel, const double value) {
		return slave->setFrequencyCorrection(direction, channel, value);
	}

	double getFrequencyCorrection(const int direction, const size_t channel) const {
		return slave->getFrequencyCorrection(direction, channel);
	}

	std::vector<std::string> listGains(const int direction, const size_t channel) const {
		return slave->listGains(direction, channel);
	}

	bool hasGainMode(const int direction, const size_t channel) const {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->hasGainMode(direction, channel);
	}

	void setGainMode(const int direction, const size_t channel, const bool automatic) {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->setGainMode(direction, channel, automatic);
	}

	bool getGainMode(const int direction, const size_t channel) const {
		return slave->getGainMode(direction, channel);
	}

	void setGain(const int direction, const size_t channel, const double value) {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->setGain(direction, channel, value);
	}

	void setGain(const int direction, const size_t channel, const std::string & name, const double value) {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->setGain(direction, channel, name, value);
	}

	double getGain(const int direction, const size_t channel) const {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->getGain(direction, channel);
	}

	double getGain(const int direction, const size_t channel, const std::string & name) const {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->getGain(direction, channel, name);
	}

	SoapySDR::Range getGainRange(const int direction, const size_t channel) const {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->getGainRange(direction, channel);
	}

	SoapySDR::Range getGainRange(const int direction, const size_t channel, const std::string & name) const {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->getGainRange(direction, channel, name);
	}

	double getFrequency(const int direction, const size_t channel) const {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->getFrequency(direction, channel);
	}

	double getFrequency(const int direction, const size_t channel, const std::string & name) const {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->getFrequency(direction, channel, name);
	}

	std::vector<std::string> listFrequencies(const int direction, const size_t channel) const {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->listFrequencies(direction, channel);
	}

	SoapySDR::RangeList getFrequencyRange(const int direction, const size_t channel) const {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->getFrequencyRange(direction, channel);
	}

	SoapySDR::RangeList getFrequencyRange(const int direction, const size_t channel, const std::string & name) const {
		return slave->getFrequencyRange(direction, channel, name);
	}

	SoapySDR::ArgInfoList getFrequencyArgsInfo(const int direction, const size_t channel) const {
		return slave->getFrequencyArgsInfo(direction, channel);
	}

	double getSampleRate(const int direction, const size_t channel) const {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->getSampleRate(direction, channel);
	}

	std::vector<double> listSampleRates(const int direction, const size_t channel) const {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->listSampleRates(direction, channel);
	}

	SoapySDR::RangeList getSampleRateRange(const int direction, const size_t channel) const {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->getSampleRateRange(direction, channel);
	}

	void setBandwidth(const int direction, const size_t channel, const double bw) {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->setBandwidth(direction, channel, bw);
	}

	double getBandwidth(const int direction, const size_t channel) const {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->getBandwidth(direction, channel);
	}

	std::vector<double> listBandwidths(const int direction, const size_t channel) const {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->listBandwidths(direction, channel);
	}

	SoapySDR::RangeList getBandwidthRange(const int direction, const size_t channel) const {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->getBandwidthRange(direction, channel);
	}

	void setMasterClockRate(const double rate) {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->setMasterClockRate(rate);
	}

	double getMasterClockRate(void) const {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->getMasterClockRate();
	}

	SoapySDR::RangeList getMasterClockRates(void) const {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->getMasterClockRates();
	}

	std::vector<std::string> listClockSources(void) const {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->listClockSources();
	}

	void setClockSource(const std::string & source) {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->setClockSource(source);
	}

	std::string getClockSource(void) const {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->getClockSource();
	}

	std::vector<std::string> listTimeSources(void) const {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->listTimeSources();
	}

	void setTimeSource(const std::string & source) {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->setTimeSource(source);
	}

	std::string getTimeSource(void) const {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->getTimeSource();
	}

	bool hasHardwareTime(const std::string & what) const {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->hasHardwareTime(what);
	}

	long long getHardwareTime(const std::string & what) const {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->getHardwareTime(what);
	}

	void setHardwareTime(const long long timeNs, const std::string & what) {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->setHardwareTime(timeNs, what);
	}

	void setCommandTime(const long long timeNs, const std::string & what) {
		return slave->setCommandTime(timeNs, what);
	}

	std::vector<std::string> listSensors(void) const {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->listSensors();
	}

	SoapySDR::ArgInfo getSensorInfo(const std::string & key) const {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->getSensorInfo(key);
	}

	std::string readSensor(const std::string & key) const {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->readSensor(key);
	}

	std::vector<std::string> listSensors(const int direction, const size_t channel) const {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->listSensors(direction, channel);
	}

	SoapySDR::ArgInfo getSensorInfo(const int direction, const size_t channel, const std::string & key) const {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->getSensorInfo(direction, channel, key);
	}

	std::string readSensor(const int direction, const size_t channel, const std::string & key) const {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->readSensor(direction, channel, key);
	}

	std::vector<std::string> listRegisterInterfaces(void) const {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->listRegisterInterfaces();
	}

	void writeRegister(const std::string & name, const unsigned addr, const unsigned value) {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->writeRegister(name, addr, value);
	}

	unsigned readRegister(const std::string & name, const unsigned addr) const {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->readRegister(name, addr);
	}

	void writeRegister(const unsigned addr, const unsigned value) {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->writeRegister(addr, value);
	}

	unsigned readRegister(const unsigned addr) const {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->readRegister(addr);
	}

	void writeRegisters(const std::string & name, const unsigned addr, const std::vector<unsigned> & value) {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->writeRegisters(name, addr, value);
	}

	std::vector<unsigned> readRegisters(const std::string & name, const unsigned addr, const size_t length) const {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->readRegisters(name, addr, length);
	}

	SoapySDR::ArgInfoList getSettingInfo(void) const {
		assert(slave.get() != nullptr);
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->getSettingInfo();
	}

	void writeSetting(const std::string & key, const std::string & value) {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->writeSetting(key, value);
	}

	std::string readSetting(const std::string & key) const {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->readSetting(key);
	}

	SoapySDR::ArgInfoList getSettingInfo(const int direction, const size_t channel) const {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->getSettingInfo(direction, channel);
	}

	void writeSetting(const int direction, const size_t channel, const std::string & key, const std::string & value) {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->writeSetting(direction, channel, key, value);
	}

	std::string readSetting(const int direction, const size_t channel, const std::string & key) const {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->readSetting(direction, channel, key);
	}

	std::vector<std::string> listGPIOBanks(void) const {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->listGPIOBanks();
	}

	void writeGPIO(const std::string & bank, const unsigned value) {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->writeGPIO(bank, value);
	}

	void writeGPIO(const std::string & bank, const unsigned value, const unsigned mask) {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->writeGPIO(bank, value, mask);
	}

	unsigned readGPIO(const std::string & bank) const {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->readGPIO(bank);
	}

	void writeGPIODir(const std::string & bank, const unsigned dir) {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->writeGPIODir(bank, dir);
	}

	void writeGPIODir(const std::string & bank, const unsigned dir, const unsigned mask) {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->writeGPIODir(bank, dir, mask);
	}

	unsigned readGPIODir(const std::string & bank) const {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->readGPIODir(bank);
	}

	void writeI2C(const int addr, const std::string & data) {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->writeI2C(addr, data);
	}

	std::string readI2C(const int addr, const size_t numBytes) {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->readI2C(addr, numBytes);
	}

	unsigned transactSPI(const int addr, const unsigned data, const size_t numBits) {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->transactSPI(addr, data, numBits);
	}

	std::vector<std::string> listUARTs(void) const {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->listUARTs();
	}

	void writeUART(const std::string & which, const std::string & data) {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->writeUART(which, data);
	}

	std::string readUART(const std::string & which, const long timeoutUs) const {
		boost::mutex::scoped_lock lock(hw_mutex);
		return slave->readUART(which, timeoutUs);
	}
	/*****************************
	 * End of generated wrappers
	 *****************************/

private:

	void spawnTxThread();
	int timestampedReadStream(SoapySDR::Stream *stream, void *const *buffs, size_t numElems, int &flags, long long &timeNs, const long timeoutUs);
	int simpleReadStream(SoapySDR::Stream *stream, void *const *buffs, size_t numElems, int &flags, long long &timeNs, const long timeoutUs);

	std::string shm;
	bool timestamped;

	std::shared_ptr<SoapySDR::Device> slave;
	mutable boost::mutex hw_mutex;

	/*
	 * RX variables
	 */
	std::unique_ptr<SharedRingBuffer> rx_buffer;
	SoapySDR::Stream* rx_stream; // Slave device stream handle
	size_t block_size;
	size_t n_blocks;

#ifdef SUPPORT_SOAPY_CONVERTERS
	std::unique_ptr<SoapySDR::ConverterRegistry::ConverterFunction> converter;
#endif

	/*
	 * TX variables
	 */
	//std::unique_ptr<SharedRingBuffer> tx_buffer;
	SoapySDR::Stream* tx_stream;                         // Slave device stream handle
	std::shared_ptr<TransmitThreadDescription> tx_info;
	std::unique_ptr<boost::thread> tx_thread;
};

/***********************************************************************
 * Find available devices
 **********************************************************************/
SoapySDR::KwargsList findSeeder(const SoapySDR::Kwargs &args);

/***********************************************************************
 * Make device instance
 **********************************************************************/
SoapySDR::Device *makeSeeder(const SoapySDR::Kwargs &args);
